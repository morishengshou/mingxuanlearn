Java 的可达性分析（Reachability Analysis）是垃圾回收器（GC）用来判断对象是否“存活”的核心算法。它通过从一组称为“GC Roots”（根对象、根集合）的起点出发，沿着对象引用关系进行遍历（通常是图的可达性搜索），凡是能从 GC Roots 到达的对象被认为是“可达”的，视为存活；无法到达的对象是“不可达”的，视为可回收。

要点概览：
- GC Roots 包括哪些
  - 虚拟机栈中各线程的栈帧本地变量表中的引用（方法参数、局部变量、临时引用）
  - 本地方法栈（JNI）中的引用
  - 方法区中类的静态字段引用
  - 方法区中常量（如字符串常量池）中的引用
  - 被同步锁持有的对象（monitor）
  - 活跃的类加载器
  - JIT 编译器、GC 自身的内部结构引用等（实现相关）
- 遍历方式
  - 通常使用标记-清除或其变体中的“标记”阶段：从 Roots 出发，图遍历（DFS/BFS/三色标记）给对象打上“存活”标记。
  - 遍历只沿“强引用”前进；软引用、弱引用、虚引用在不同阶段有不同的处理策略（如可能在内存紧张或本次 GC 中被清除）。
- 与“引用计数”的对比
  - 可达性分析能正确处理循环引用（两个对象互相引用但从 Roots 不可达会被回收），这是引用计数难以处理的问题。
- 分代与并发 GC 中的应用
  - 年轻代/老年代采用写屏障与记忆集，保证跨代引用在并发或分区回收时不漏标。
  - 并发标记（如 CMS、G1、ZGC、Shenandoah）使用三色标记 + 屏障（写屏障/读屏障）维护“快照”或“增量更新”，确保并发时的可达性正确。
- 对象何时真正死亡
  - 第一次不可达：对大多数对象意味着可回收。
  - 具有 finalize() 的对象：第一次不可达会被放入 F-Queue，可能在执行 finalize() 后“复活”（再次变为可达）；若再次不可达才会真正回收。现代实践建议避免使用 finalize（已被废弃），改用 try-with-resources/清理器。
- 与根可达性的边界情况
  - 线程仍在运行的栈上持有的引用（包括编译器优化可能延长或缩短引用存活）
  - 安全点/安全区域：为了进行停顿式或并发标记，JVM 需要线程在可中断位置到达“安全点”，从而精确枚举 Roots。
- 实践意义
  - 了解可达性有助于解释内存泄漏：对象被无意中保存在长生命周期的 Root 可达结构里（静态集合、缓存、回调、线程本地变量等）即不会被回收。
  - 调优时关注：对象存活率、跨代引用、写屏障开销、停顿时间与吞吐的权衡。

简要流程（以标记-清除为例）：
1) 枚举 GC Roots（扫描线程栈、JNI 引用、静态字段等）。
2) 从 Roots 出发遍历引用图，对可达对象“标记”。
3) 未标记对象视为不可达，进入回收；之后可能伴随整理/压缩以消除碎片。

一句话总结：可达性分析就是“从一组根对象出发，凡能沿引用链到达的对象就是活的”，它让 JVM 在存在循环引用和并发执行的情况下，仍能正确、高效地判定垃圾。