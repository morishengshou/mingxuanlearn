下面是对 Java 中 assert 关键字的系统讲解，包括作用、语法、适用场景、与异常/日志的区别、启用方式以及不使用它带来的不便。

一、assert 是什么
- assert 是 Java 1.4 引入的断言机制，用于在开发/测试阶段主动检查程序中的“永远应该为真”的条件。
- 当条件为 false 时，断言会抛出 AssertionError，提示存在逻辑错误或不变式（invariant）被破坏。
- 断言通常只在开发与测试环境启用，生产环境默认关闭，不参与正常业务逻辑。

二、语法
- 基本形式：
  - assert 条件表达式;
- 带消息的形式：
  - assert 条件表达式 : 表达式;
  - 第二个表达式会在断言失败时转为字符串并放到 AssertionError 的消息里，用于定位问题。

示例：
```java
int idx = ...;
assert idx >= 0 && idx < list.size() : "index out of range: " + idx;
```

三、如何启用/禁用
- 默认：JVM 运行时断言是关闭的（不检查，且没有开销，除了断言语句本身的解析）。
- 启用断言：
  - java -ea 或 java -enableassertions
  - 针对包/类启用：-ea:com.example... 或 -ea:com.example.MyClass
- 禁用断言：
  - java -da 或 java -disableassertions
- 注意：不要把断言依赖为业务逻辑的一部分，因为生产环境通常关闭断言。

四、什么时候使用断言
断言用于“永远应该成立”的内部假设，帮助尽早暴露编程错误，而非处理可预期的业务异常。

典型场景：
1) 内部不变式检查
- 类或方法内部状态约束，理论上不应被外部输入破坏。
```java
assert balance >= 0 : "Negative balance: " + balance;
```

2) 前置/后置条件（针对受控代码边界）
- 前置条件：方法私有调用场景，或你能完全控制的调用方（非公开 API）。
```java
private int sqrt(int x) {
    assert x >= 0 : "x must be non-negative";
    ...
}
```
- 后置条件：确保方法返回后的状态满足预期。
```java
int result = compute(...);
assert result >= 0 : "result should be non-negative";
```

3) 复杂分支的不可能分支
```java
switch (state) {
  case INIT: ...
  case RUNNING: ...
  case STOPPED: ...
  default:
    assert false : "Unexpected state: " + state;
}
```

4) 协议/约定检查（模块内部）
- 多线程共享状态、缓存一致性、对象生命周期的约束。

5) 性能敏感的开发期校验
- 断言在生产关闭后没有运行时代价（除了字节码中的占位），适合在开发期大量加入廉价校验。

不适合用断言的场景：
- 用户输入校验、网络/IO错误、可恢复的业务错误、公共 API 的参数校验。这些应抛出受检异常或运行时异常，并在生产环境生效。

五、断言与异常/日志的区别
- 断言（assert）
  - 面向开发期的“永真条件”的验证，失败意味着编程错误。
  - 可在生产禁用，不能用于业务流程控制。
- 异常（Exception）
  - 面向运行时错误与可预期失败，属于业务或环境问题，需要处理或上抛。
  - 永远在生产生效。
- 日志（logging）
  - 记录运行信息，不改变控制流。
  - 不能保证及时暴露逻辑错误。

六、使用它是为了解决什么问题
- 快速暴露隐藏的编程错误：例如错误的推断、不变量破坏、意外分支。
- 提升代码自文档化程度：用可执行的方式表达约束与假设，便于维护者理解。
- 在不影响生产性能的前提下，进行丰富的运行时一致性检查。

七、如果不使用它会有什么不方便
- 缺少统一的开发期“硬防护”：逻辑错误可能在测试中被忽略，直到线上以更隐蔽的症状出现。
- 约束只能写在注释或文档里：不具备可执行性，容易被违背而不自知。
- 需要用异常替代断言
  - 会在生产环境始终抛出并影响控制流或性能；
  - 或者为了性能不加检查，降低代码健壮性。
- 难以及早定位“不可能发生”的路径：没有断言时，这类错误会以更奇怪的地方崩溃。

八、最佳实践与注意事项
- 不要在断言中写有副作用的代码：
  ```java
  assert i++ < n; // 断言关闭时不会执行，副作用消失，导致行为不一致
  ```
- 断言消息要提供定位信息：包含关键变量值与上下文。
- 公共 API 参数校验使用异常，而非断言：
  ```java
  public void setAge(int age) {
      if (age < 0) throw new IllegalArgumentException("age < 0");
  }
  ```
- 可以在关键路径上增加“轻断言”：
  - 例如只做引用非空/范围检查，避免构造昂贵消息；若需要昂贵计算放到消息里用三元判断：
  ```java
  assert obj != null : "obj is null"; // 简单
  assert cond : (DEBUG ? expensiveMessage() : ""); // 或者用 lambda/方法并在 DEBUG 时调用
  ```
- 针对库/框架开发，建议在内部边界大量使用断言，外部边界用异常和明确的错误返回。

九、与单元测试的关系
- 单元测试验证对外可观察行为；断言验证运行时内部不变式。
- 二者互补：单测覆盖不了所有路径与内部状态，断言可在实际运行中持续监控内部假设。

十、小结
- assert 用于表达开发者的“永远为真”的内部假设和不变式，失败即编程错误。
- 在开发/测试启用以尽早发现问题；生产通常关闭，避免影响性能与用户体验。
- 不使用断言会让内部约束失去可执行的验证，隐藏 bug 更难被及时发现或定位。