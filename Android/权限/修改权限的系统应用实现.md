下面给你一套面向 Android 12+（SDK 31/32/33/34 及以上可按需适配）的系统/特权应用实现方案，使用 Java 编写，支持授予/撤销其他应用的运行时权限，并在需要时同步 AppOps、受限权限白名单与多用户。请注意：此能力仅对系统签名或特权应用开放，普通应用不可用。

一、前置条件与总体思路
- 你的 APK 必须：
  - 预装为系统/特权应用：放入 /system/priv-app。
  - 使用平台证书签名（与系统相同 key），并在 privapp-permissions 中授予相应 signature|privileged 权限。
- 关键权限（在 Manifest 声明，并通过 privapp-permissions 下发）：
  - android.permission.GRANT_RUNTIME_PERMISSIONS
  - android.permission.REVOKE_RUNTIME_PERMISSIONS
  - android.permission.MANAGE_APP_OPS_MODES（配合 AppOps）
  - android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY（可选，控制自动重置等策略）
  - android.permission.INTERACT_ACROSS_USERS 或 INTERACT_ACROSS_USERS_FULL（跨用户）
  - android.permission.QUERY_ALL_PACKAGES（可选，便于查询包）
- 主要 API：
  - PackageManager.grantRuntimePermission(...)
  - PackageManager.revokeRuntimePermission(...)
  - AppOpsManager.setMode(...) / setUidMode(...)
  - PackageManager.addWhitelistedRestrictedPermission(...)（针对受限权限）
  - RoleManager（可选，默认应用角色可能隐式授予权限）
- 版本要点（31+）：
  - Android 12（S）：通知权限尚非运行时；蓝牙权限拆分（BLUETOOTH_SCAN/CONNECT/ADVERTISE），附近设备权限 NEARBY_WIFI_DEVICES（13+）。
  - Android 13（Tiramisu，33）：POST_NOTIFICATIONS 成为运行时权限；READ_MEDIA_* 拆分。
  - Android 14（34）：更多受限权限与 auto-reset 策略强化，部分受限权限需白名单。

二、Manifest 与 privapp-permissions
AndroidManifest.xml（片段）：
```xml
<manifest ...>
    <uses-sdk android:minSdkVersion="31" android:targetSdkVersion="33" />
    <uses-permission android:name="android.permission.GRANT_RUNTIME_PERMISSIONS" />
    <uses-permission android:name="android.permission.REVOKE_RUNTIME_PERMISSIONS" />
    <uses-permission android:name="android.permission.MANAGE_APP_OPS_MODES" />
    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />
    <uses-permission android:name="android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY" />
    <application android:label="@string/app_name">
        ...
    </application>
</manifest>
```

privapp-permissions-<oem>.xml：
```xml
<permissions>
  <privapp-permissions package="com.example.sysperm">
    <permission name="android.permission.GRANT_RUNTIME_PERMISSIONS"/>
    <permission name="android.permission.REVOKE_RUNTIME_PERMISSIONS"/>
    <permission name="android.permission.MANAGE_APP_OPS_MODES"/>
    <permission name="android.permission.INTERACT_ACROSS_USERS"/>
    <permission name="android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY"/>
    <permission name="android.permission.QUERY_ALL_PACKAGES"/>
  </privapp-permissions>
</permissions>
```

三、核心 Java 实现示例
说明：
- 工具类 SystemPermissionManager 提供授予、撤销、同步 AppOps、受限权限白名单、跨用户支持。
- 请在系统签名与 priv-app 环境下运行，否则会抛 SecurityException。

```java
package com.example.sysperm;

import android.app.AppOpsManager;
import android.app.AppOpsManager.OpEntry;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PermissionInfo;
import android.os.Build;
import android.os.Process;
import android.os.UserHandle;
import android.text.TextUtils;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class SystemPermissionManager {

    private static final String TAG = "SystemPermissionManager";

    private final Context context;
    private final PackageManager pm;
    private final AppOpsManager appOps;

    public SystemPermissionManager(Context context) {
        this.context = context.getApplicationContext();
        this.pm = this.context.getPackageManager();
        this.appOps = this.context.getSystemService(AppOpsManager.class);
    }

    // 授予运行时权限（必要时为受限权限加白）
    public void grantRuntimePermission(String packageName, String permission, UserHandle user) throws Exception {
        ensureArgs(packageName, permission);
        ensurePackageExists(packageName, user);

        PermissionInfo pi = pm.getPermissionInfo(permission, 0);
        if (!isRuntimeOrSpecial(pi)) {
            throw new IllegalArgumentException("Permission is not runtime or changeable: " + permission);
        }

        // 针对受限权限（restricted）先白名单（Android 10+ 部分权限）
        maybeWhitelistRestrictedPermission(packageName, permission, user);

        try {
            pm.grantRuntimePermission(packageName, permission, user);
            Log.i(TAG, "Granted " + permission + " to " + packageName + " for user " + user.getIdentifier());
        } catch (SecurityException se) {
            Log.e(TAG, "Missing GRANT_RUNTIME_PERMISSIONS or not privileged/system-signed", se);
            throw se;
        }

        // 某些能力需要同步 AppOps（例如后台定位、读取剪贴板历史在老版本）。
        maybeAlignAppOps(packageName, permission, true);
    }

    // 撤销运行时权限
    public void revokeRuntimePermission(String packageName, String permission, UserHandle user) throws Exception {
        ensureArgs(packageName, permission);
        ensurePackageExists(packageName, user);

        PermissionInfo pi = pm.getPermissionInfo(permission, 0);
        if (!isRuntimeOrSpecial(pi)) {
            throw new IllegalArgumentException("Permission is not runtime or changeable: " + permission);
        }

        try {
            pm.revokeRuntimePermission(packageName, permission, user);
            Log.i(TAG, "Revoked " + permission + " from " + packageName + " for user " + user.getIdentifier());
        } catch (SecurityException se) {
            Log.e(TAG, "Missing REVOKE_RUNTIME_PERMISSIONS or not privileged/system-signed", se);
            throw se;
        }

        maybeAlignAppOps(packageName, permission, false);
    }

    // 一次性授予一组权限（自动过滤不存在或非运行时）
    public List<String> grantRuntimePermissionsBatch(String packageName, List<String> permissions, UserHandle user) {
        List<String> granted = new ArrayList<>();
        for (String p : permissions) {
            try {
                PermissionInfo pi = pm.getPermissionInfo(p, 0);
                if (!isRuntimeOrSpecial(pi)) continue;
                maybeWhitelistRestrictedPermission(packageName, p, user);
                pm.grantRuntimePermission(packageName, p, user);
                granted.add(p);
                maybeAlignAppOps(packageName, p, true);
            } catch (Throwable t) {
                Log.w(TAG, "Grant failed for " + p + ": " + t);
            }
        }
        return granted;
    }

    // 同步 AppOps：依据权限映射到对应 op 并设置 MODE_ALLOWED / MODE_IGNORED
    private void maybeAlignAppOps(String packageName, String permission, boolean allowed) {
        if (appOps == null) return;
        String op = AppOpsManager.permissionToOp(permission);
        if (op == null) {
            // 某些能力没有直接映射，针对特殊场景可单独处理
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && 
                "android.permission.ACCESS_BACKGROUND_LOCATION".equals(permission)) {
                setOp(packageName, AppOpsManager.OPSTR_ACCESS_BACKGROUND_LOCATION, allowed);
            }
            return;
        }
        setOp(packageName, op, allowed);
    }

    private void setOp(String packageName, String op, boolean allowed) {
        try {
            int uid = pm.getApplicationInfo(packageName, 0).uid;
            int mode = allowed ? AppOpsManager.MODE_ALLOWED : AppOpsManager.MODE_IGNORED;
            appOps.setMode(op, uid, packageName, mode);
            Log.i(TAG, "AppOp " + op + " for " + packageName + " -> " + (allowed ? "ALLOWED" : "IGNORED"));
        } catch (Throwable t) {
            Log.w(TAG, "setOp failed: " + op + " for " + packageName + " : " + t);
        }
    }

    // 对受限权限加白（根据平台支持情况）
    private void maybeWhitelistRestrictedPermission(String packageName, String permission, UserHandle user) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                // Flags：WHITELIST_REASON_UNKNOWN(0) 或 其他特定原因
                pm.addWhitelistedRestrictedPermission(packageName, permission, PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM);
                Log.i(TAG, "Whitelisted restricted permission " + permission + " for " + packageName);
            }
        } catch (Throwable t) {
            // 并非所有权限需要白名单，失败可以忽略或记日志
            Log.w(TAG, "Whitelist restricted permission failed: " + permission + " : " + t);
        }
    }

    private boolean isRuntimeOrSpecial(PermissionInfo pi) {
        final int protection = pi.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;
        final int flags = pi.protectionLevel & PermissionInfo.PROTECTION_MASK_FLAGS;
        boolean runtime = protection == PermissionInfo.PROTECTION_DANGEROUS;
        boolean signature = protection == PermissionInfo.PROTECTION_SIGNATURE;
        boolean isRestricted = (flags & PermissionInfo.PROTECTION_FLAG_APPOP) != 0
                || (flags & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0
                || (flags & PermissionInfo.PROTECTION_FLAG_OEM) != 0
                || (flags & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0;
        // 允许 runtime；对于 signature 一般不能随意改，除非同签名并处于系统上下文；这里主要限制 runtime。
        return runtime || isRestricted;
    }

    private void ensureArgs(String pkg, String perm) {
        if (TextUtils.isEmpty(pkg) || TextUtils.isEmpty(perm)) {
            throw new IllegalArgumentException("packageName/permission is empty");
        }
    }

    private void ensurePackageExists(String packageName, UserHandle user) throws NameNotFoundException {
        // 注意：跨用户场景下可使用 PackageManager.MATCH_ANY_USER 变体，但普通 API 会检查当前用户。
        pm.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
    }

    // 查询当前授予状态
    public boolean isPermissionGranted(String packageName, String permission, UserHandle user) {
        try {
            PackageInfo pi = pm.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
            if (pi.requestedPermissions == null) return false;
            for (int i = 0; i < pi.requestedPermissions.length; i++) {
                if (permission.equals(pi.requestedPermissions[i])) {
                    int[] flags = pi.requestedPermissionsFlags;
                    // 对于 31+，可以结合 pm.checkPermission 使用
                    return pm.checkPermission(permission, packageName) == PackageManager.PERMISSION_GRANTED;
                }
            }
        } catch (Exception ignored) {}
        return false;
    }

    // 便捷方法：当前用户
    public static UserHandle currentUser() {
        return Process.myUserHandle();
    }
}
```

四、使用示例（Java，Activity/Service 中）
```java
SystemPermissionManager spm = new SystemPermissionManager(this);

// 目标包与权限
String targetPkg = "com.example.target";

// 典型权限示例（根据目标 Android 版本选择）
List<String> toGrant = Arrays.asList(
        android.Manifest.permission.ACCESS_FINE_LOCATION,
        android.Manifest.permission.READ_CONTACTS,
        android.Manifest.permission.CAMERA
);

// Android 13+ 运行时通知权限
if (Build.VERSION.SDK_INT >= 33) {
    toGrant.add(android.Manifest.permission.POST_NOTIFICATIONS);
}

// 授权
try {
    for (String p : toGrant) {
        spm.grantRuntimePermission(targetPkg, p, SystemPermissionManager.currentUser());
    }
} catch (Exception e) {
    e.printStackTrace();
}

// 撤销
try {
    spm.revokeRuntimePermission(targetPkg, android.Manifest.permission.CAMERA, SystemPermissionManager.currentUser());
} catch (Exception e) {
    e.printStackTrace();
}
```

五、定位/附近设备等特殊权限处理
- 后台定位（ACCESS_BACKGROUND_LOCATION，Android 10+）：grant 后常需设置对应 AppOp OPSTR_ACCESS_BACKGROUND_LOCATION 为 MODE_ALLOWED。
- 精确/模糊定位（Android 12+）：应用可请求精确与模糊，系统侧授予 ACCESS_FINE_LOCATION 即可，是否精确由 App 侧请求与用户选择控制；部分 OEM 会通过 AppOps 控制精度。
- 附近设备与蓝牙（Android 12+）：
  - BLUETOOTH_SCAN/CONNECT/ADVERTISE 为 runtime。
  - Android 13+ 的 NEARBY_WIFI_DEVICES 是独立运行时权限。
- 通知（Android 13+）：POST_NOTIFICATIONS 为 runtime，可直接 grantRuntimePermission。

六、跨用户/工作资料夹
- 如果需要对非当前用户授权，请使用对应 UserHandle（UserManager 获取）并持有 INTERACT_ACROSS_USERS[_FULL]。
- 可监听包变更广播，在新用户或新安装时自动应用策略：
  - ACTION_PACKAGE_ADDED、ACTION_PACKAGE_CHANGED、ACTION_PACKAGE_REPLACED
  - 结合 pm.getInstalledPackagesAsUser 等方法（隐藏 API 在 AOSP 内部，外部可用反射或切换到 shell/系统接口）。

七、测试与调试
- adb 验证：
  - adb shell pm grant <pkg> <perm>
  - adb shell pm revoke <pkg> <perm>
  - adb shell appops get <pkg>
  - adb shell dumpsys package <pkg>
- 常见错误：
  - SecurityException: 缺少 GRANT/REVOKE_RUNTIME_PERMISSIONS 或非系统签名/非 priv-app。
  - IllegalArgumentException: 权限不是 runtime/未知权限/目标包不存在。
  - 授权后功能无效：对应 AppOps 未同步或权限受限未白名单。
  - Android 13+ 通知权限：目标应用需 targetSdk 33+ 时才生效其运行时语义。

八、可选：Device Owner/MDM 路径
如果可将你的应用设置为设备所有者（Device Owner），可使用 DevicePolicyManager.setPermissionGrantState(package, permission, GRANT_STATE_GRANTED/DEFAULT/DENIED) 实现更合规的集中控制。适合企业设备场景，但需开机引导或 adb 设置 DO。

九、补充建议
- 将权限映射到 AppOps 的表维护在代码中，以适配不同版本的特例。
- 对受限权限维护白名单清单，提前批量 addWhitelistedRestrictedPermission。
- 在 Android 14/15 上，注意 auto-reset 与受限权限的策略变更；必要时使用 ADJUST_RUNTIME_PERMISSIONS_POLICY 或在 PermissionController 定制策略。

如果你告知目标设备的具体 Android 大版本（例如 12、13、14）、要批量控制的权限清单、是否需要跨用户支持，我可以给出更精确的权限→AppOps 映射和版本分支代码。