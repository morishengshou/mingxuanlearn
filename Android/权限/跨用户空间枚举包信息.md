如果你的应用是系统应用（platform 签名或在 /system/priv-app），并且仅安装在 U0，但需要枚举其他用户空间的已安装应用列表，你需要满足并实现以下要点：

前提与权限要求
- 必备权限（至少其一，通常两者都授予给系统/priv-app）：
  - android.permission.INTERACT_ACROSS_USERS
  - android.permission.INTERACT_ACROSS_USERS_FULL
- 包可见性（Android 11+）：
  - 对于系统/priv-app，通常不受普通可见性限制，但在 Android 11+ 仍建议：
    - 在 manifest 中声明 <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />
    - 或在需要时补充 <queries>（多数系统 app 不必）
- 如果要跨用户发起包管理操作（安装/卸载/冻结等），还可能需要：
  - android.permission.MANAGE_USERS 或 android.permission.INTERACT_ACROSS_USERS[_FULL]
  - android.permission.DELETE_PACKAGES / INSTALL_PACKAGES（视操作而定）

核心思路与代码
- 通过 createContextAsUser 获取目标用户的上下文，再用该上下文的 PackageManager 查询。
- 用户列表可通过 UserManager 获取。

Kotlin 示例
- 列出所有用户的已安装包（需要跨用户权限）
fun listPackagesForAllUsers(context: Context): Map<Int, List<PackageInfo>> {
    val result = mutableMapOf<Int, List<PackageInfo>>()

    val um = context.getSystemService(UserManager::class.java)
    val users: List<UserHandle> = if (Build.VERSION.SDK_INT >=  thirtyThree()) {
        um.userProfiles // 或 um.getUsers() 在系统权限下可用，但在部分版本为 @SystemApi
    } else {
        // 尝试 getUserHandles 或反射；更稳妥做法见下方 Java 版本注释
        @Suppress("Deprecation")
        um.userProfiles
    }

    // 如果拿不到完整用户列表，可以改用 UserManager::class.java 的 @SystemApi getUsers 需系统权限，或由 DevicePolicyManager 枚举受管用户。
    val targetUsers = users.ifEmpty { listOf(UserHandle.SYSTEM) }

    for (uh in targetUsers) {
        try {
            val ctxOther = context.createContextAsUser(uh, 0)
            val pmOther = ctxOther.packageManager
            val list = if (Build.VERSION.SDK_INT >= 33) {
                pmOther.getInstalledPackages(PackageManager.PackageInfoFlags.of(0))
            } else {
                @Suppress("Deprecation")
                pmOther.getInstalledPackages(0)
            }
            result[uh.identifier] = list
        } catch (se: SecurityException) {
            // 缺少跨用户权限，或该 user 不可访问
            result[uh.identifier] = emptyList()
        }
    }
    return result
}

// 简单的 API 级别辅助
private fun thirtyThree() = 33

Java 核心片段
UserManager um = context.getSystemService(UserManager.class);
// 获取用户句柄列表（取决于系统版本与权限）
// API 可选：um.getUsers() 为 @SystemApi；有些 ROM 开放，有些需反射或使用 DevicePolicyManager。
List<UserHandle> handles = um.getUserProfiles(); // 可能只返回当前用户/配置文件
for (UserHandle uh : handles) {
    try {
        Context ctxOther = context.createContextAsUser(uh, 0);
        PackageManager pmOther = ctxOther.getPackageManager();
        List<PackageInfo> pkgs;
        if (Build.VERSION.SDK_INT >= 33) {
            pkgs = pmOther.getInstalledPackages(PackageManager.PackageInfoFlags.of(0));
        } else {
            pkgs = pmOther.getInstalledPackages(0);
        }
        // 使用 pkgs
    } catch (SecurityException e) {
        // 跨用户权限不足
    }
}

获取完整用户列表的途径
- 标准 API 常见限制：
  - UserManager.getUserProfiles() 通常只返回当前用户以及关联的配置文件（如工作资料），不一定包含系统上所有 users。
- 系统/企业场景可用方式：
  - UserManager.getUsers()：@SystemApi，仅系统 app 可访问，且需要 MANAGE_USERS 或 INTERACT_ACROSS_USERS_FULL。
  - DevicePolicyManager.getUsers() / getUserProfiles()：在设备所有者/管理员场景可用。
  - 使用 adb 或 OEM 提供的系统服务接口（不建议在通用代码中依赖）。

Manifest 示例
<manifest ...>
    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS_FULL" />
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />
    <!-- 如需用户管理能力 -->
    <uses-permission android:name="android.permission.MANAGE_USERS" />
    <!-- 如果要安装/卸载等操作 -->
    <!-- <uses-permission android:name="android.permission.INSTALL_PACKAGES" />
    <uses-permission android:name="android.permission.DELETE_PACKAGES" /> -->
    ...
</manifest>

常见问题与排查
- SecurityException：说明缺少跨用户权限或目标用户受限制。确认你的 APK 与平台签名一致，且在 /system/priv-app；检查 privapp-permissions 的白名单是否包含上述权限（Android 9+ 强制白名单）。
- 仅能看到 U0 或当前 profile：
  - 你获取的是 profiles 不是所有 users。需要使用系统 API getUsers() 或通过 DPM 在 DO 设备上枚举。
- Android 10+ 的 privapp 权限白名单：
  - 若是 priv-app，需要将权限加入 /system/etc/permissions/privapp-permissions-<oem>.xml 或 /vendor/etc/permissions/privapp-permissions-<oem>.xml 中，否则系统会在启动时剥夺声明的特权权限。
- 包可见性依旧受限：
  - 在 Android 11+ 上，跨用户上下文下的 PackageManager 也可能受用户空间策略限制（例如该 user 的工作/企业策略）。但系统/priv 权限通常可见。

总结
- 作为系统应用，你需要 INTERACT_ACROSS_USERS 或 INTERACT_ACROSS_USERS_FULL（以及可能的 MANAGE_USERS）来跨用户创建上下文，并在该上下文中使用 PackageManager 查询。
- 枚举“所有用户”时，核心是先正确获取目标 UserHandle 列表（getUsers/@SystemApi 或 DPM），再针对每个 user 调用 createContextAsUser(...).getPackageManager().getInstalledPackages(...).
- 确认特权权限在设备的 privapp 白名单中实际授予，否则即便是系统应用也会被拒绝。