下面是等价的 Java 版本工具类，涵盖：
- 判断某一权限是否授予
- 列出指定包的全部请求权限、授予状态、权限标志以及对应 AppOps 模式
- 查询某一特定权限的状态
- 可选跨用户查询（需系统/跨用户权限）

```java
package your.pkg;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Process;
import android.os.UserHandle;
import android.app.AppOpsManager;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public final class PermissionInspector {

    private PermissionInspector() {}

    // 一、最简：判断某个权限是否已授予（对其他包也可用，需包可见性）
    public static boolean isPermissionGranted(Context context, String packageName, String permission) {
        PackageManager pm = context.getPackageManager();
        return pm.checkPermission(permission, packageName) == PackageManager.PERMISSION_GRANTED;
    }

    // 二、完整查询：列出某包的权限授予状态、标志与 AppOps 模式（当前用户）
    public static List<PermissionState> queryPackagePermissions(Context context, String packageName) {
        return queryPackagePermissions(context, packageName, Process.myUserHandle());
    }

    // 二（跨用户）：需 INTERACT_ACROSS_USERS / FULL，并使用 createContextAsUser
    public static List<PermissionState> queryPackagePermissions(Context context, String packageName, UserHandle user) {
        Context userCtx = context;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && user != null) {
            userCtx = context.createContextAsUser(user, 0);
        }

        PackageManager pm = userCtx.getPackageManager();
        PackageInfo pi;
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                pi = pm.getPackageInfo(
                        packageName,
                        PackageManager.PackageInfoFlags.of(PackageManager.GET_PERMISSIONS)
                );
            } else {
                // noinspection deprecation
                pi = pm.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
            }
        } catch (PackageManager.NameNotFoundException e) {
            return Collections.emptyList();
        }

        String[] reqPerms = (pi.requestedPermissions != null) ? pi.requestedPermissions : new String[0];
        int[] reqFlags = (pi.requestedPermissionsFlags != null) ? pi.requestedPermissionsFlags : new int[reqPerms.length];
        int uid = (pi.applicationInfo != null) ? pi.applicationInfo.uid : -1;

        AppOpsManager appOps = userCtx.getSystemService(AppOpsManager.class);

        List<PermissionState> out = new ArrayList<>(reqPerms.length);
        for (int i = 0; i < reqPerms.length; i++) {
            String perm = reqPerms[i];
            int rFlags = (i < reqFlags.length) ? reqFlags[i] : 0;
            boolean granted = (rFlags & PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0;

            // 读取权限标志（系统/签名权限：GET_RUNTIME_PERMISSIONS），失败则为 0
            int flags = 0;
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    flags = pm.getPermissionFlags(perm, packageName, user != null ? user : Process.myUserHandle());
                }
            } catch (SecurityException ignored) {
            }

            List<String> flagStrings = decodePermissionFlags(flags);

            // AppOps：若权限映射到某个 op，则读取其模式
            String op = null;
            Integer mode = null;
            String modeStr = null;
            try {
                op = AppOpsManager.permissionToOp(perm);
            } catch (Throwable ignored) {
            }
            if (op != null && uid >= 0 && appOps != null) {
                try {
                    int m;
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        m = appOps.unsafeCheckOpNoThrow(op, uid, packageName);
                    } else {
                        // noinspection deprecation
                        m = appOps.checkOpNoThrow(op, uid, packageName);
                    }
                    mode = m;
                    modeStr = appOpModeToString(m);
                } catch (SecurityException ignored) {
                }
            }

            out.add(new PermissionState(
                    perm,
                    granted,
                    flags,
                    flagStrings,
                    op,
                    mode,
                    modeStr
            ));
        }
        return out;
    }

    // 三、仅查单个权限的状态（含 AppOps）
    public static PermissionState getSinglePermissionState(Context context, String packageName, String permission) {
        return getSinglePermissionState(context, packageName, permission, Process.myUserHandle());
    }

    public static PermissionState getSinglePermissionState(Context context, String packageName, String permission, UserHandle user) {
        List<PermissionState> states = queryPackagePermissions(context, packageName, user);
        for (PermissionState s : states) {
            if (permission.equals(s.name)) return s;
        }
        return null;
    }

    // —— 工具方法 ——

    private static List<String> decodePermissionFlags(int flags) {
        List<String> out = new ArrayList<>();
        if (flags == 0) return out;

        // 常见标志（不同版本可用性会有差异，缺失的常量不会影响运行）
        try { if ((flags & PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0) out.add("GRANTED_BY_DEFAULT"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0) out.add("GRANTED_BY_ROLE"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_POLICY_FIXED) != 0) out.add("POLICY_FIXED"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) out.add("SYSTEM_FIXED"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_USER_FIXED) != 0) out.add("USER_FIXED"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_USER_SET) != 0) out.add("USER_SET"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_RESTRICTION_UPGRADABLE) != 0) out.add("RESTRICTION_UPGRADABLE"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPTED) != 0) out.add("RESTRICTION_UPGRADE_EXEMPTED"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_ONE_TIME) != 0) out.add("ONE_TIME"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_AUTO_REVOKED) != 0) out.add("AUTO_REVOKED"); } catch (Throwable ignored) {}
        try { if ((flags & PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0) out.add("REVIEW_REQUIRED"); } catch (Throwable ignored) {}
        return out;
    }

    private static String appOpModeToString(int mode) {
        switch (mode) {
            case AppOpsManager.MODE_ALLOWED: return "ALLOWED";
            case AppOpsManager.MODE_IGNORED: return "IGNORED";
            case AppOpsManager.MODE_ERRORED: return "ERRORED";
            case AppOpsManager.MODE_DEFAULT: return "DEFAULT";
            default:
                // MODE_FOREGROUND 在某些版本上存在
                try {
                    if (mode == AppOpsManager.MODE_FOREGROUND) return "FOREGROUND";
                } catch (Throwable ignored) {}
                return String.valueOf(mode);
        }
    }

    // —— 数据类 ——

    public static final class PermissionState {
        public final String name;
        public final boolean granted;
        public final int flags;
        public final List<String> flagStrings;
        public final String appOp;
        public final Integer appOpMode;
        public final String appOpModeString;

        public PermissionState(String name,
                               boolean granted,
                               int flags,
                               List<String> flagStrings,
                               String appOp,
                               Integer appOpMode,
                               String appOpModeString) {
            this.name = name;
            this.granted = granted;
            this.flags = flags;
            this.flagStrings = (flagStrings != null) ? Collections.unmodifiableList(new ArrayList<>(flagStrings)) : Collections.<String>emptyList();
            this.appOp = appOp;
            this.appOpMode = appOpMode;
            this.appOpModeString = appOpModeString;
        }

        @Override
        public String toString() {
            return "PermissionState{" +
                    "name='" + name + '\'' +
                    ", granted=" + granted +
                    ", flags=" + flags +
                    ", flagStrings=" + flagStrings +
                    ", appOp='" + appOp + '\'' +
                    ", appOpMode=" + appOpMode +
                    ", appOpModeString='" + appOpModeString + '\'' +
                    '}';
        }
    }
}
```

使用示例：
- 判断某权限是否授予：
  - boolean ok = PermissionInspector.isPermissionGranted(context, "com.example.app", android.Manifest.permission.CAMERA);
- 列出全部权限状态：
  - List<PermissionInspector.PermissionState> states = PermissionInspector.queryPackagePermissions(context, "com.example.app");
- 跨用户：
  - List<PermissionInspector.PermissionState> states = PermissionInspector.queryPackagePermissions(context, "com.example.app", someUserHandle);

注意事项（与系统/特权应用相关）：
- 读取权限标志需要 android.permission.GET_RUNTIME_PERMISSIONS（签名/特权）。
- 跨用户需要 INTERACT_ACROSS_USERS 或 INTERACT_ACROSS_USERS_FULL。
- AppOps 读取其他包时使用 unsafeCheckOpNoThrow（API 29+），低版本回退到 checkOpNoThrow；若无足够权限可能抛出 SecurityException，已在代码中吞掉并返回空模式。  
- Android 11+ 包可见性限制下，确保你的应用具备 QUERY_ALL_PACKAGES 或适当的 queries 声明（平台签名通常不受限）。