可以，但需走“系统级”接口与权限，并且按“包名 + 目标用户”来授予，而不是单纯用 UID。简要要点如下：

结论
- 平台签名的特权/系统应用在 U0 中运行，持有相应签名权限后，确实可以为其他用户空间（U10、U11 …）中的应用授予/撤销运行时权限。
- 运行时权限的状态是“按用户隔离”的；你需要指定目标 UserHandle（或 userId）和包名。仅凭 UID 不够通用（权限授予 API 基本以包名为主）。AppOps 可以按 UID 设置，但很多危险权限还需要同时授予 runtime permission。

需要的关键权限（签名级）
- GRANT_RUNTIME_PERMISSIONS（授予）
- REVOKE_RUNTIME_PERMISSIONS（撤销）
- INTERACT_ACROSS_USERS 或 INTERACT_ACROSS_USERS_FULL（跨用户操作）
- 可选：MANAGE_USERS（如果还要枚举/管理用户）
- 可选：MANAGE_APP_OPS_MODES（若你还要直接改 AppOps）

Manifest 声明示例
```xml
<uses-permission android:name="android.permission.INTERACT_ACROSS_USERS"/>
<uses-permission android:name="android.permission.GRANT_RUNTIME_PERMISSIONS"/>
<uses-permission android:name="android.permission.REVOKE_RUNTIME_PERMISSIONS"/>
<uses-permission android:name="android.permission.MANAGE_APP_OPS_MODES"/> <!-- 如需 -->
<uses-permission android:name="android.permission.MANAGE_USERS"/>          <!-- 如需 -->
```

授予/撤销运行时权限（推荐）
- 使用 PackageManager 的系统 API：grantRuntimePermission/revokeRuntimePermission（自 API 23 存在，需签名权限）
- 指定目标用户的 UserHandle

示例代码（Java，API 34+）
```java
import android.content.pm.PackageManager;
import android.os.UserHandle;
import android.app.AppOpsManager;
import android.content.Context;

public final class PermUtils {

    // 授予一组危险权限到指定用户
    public static void grantDangerousPermissionsForUser(Context ctx, String pkg, int userId, String... perms) {
        PackageManager pm = ctx.getPackageManager();
        UserHandle target = UserHandle.of(userId);

        for (String p : perms) {
            try {
                pm.grantRuntimePermission(pkg, p, target);
                // 若该权限映射到 AppOps，最好同步设置为 ALLOWED（有些版本会自动做，但保险起见手动设置）
                String op = AppOpsManager.permissionToOp(p);
                if (op != null) {
                    int uid = pm.getPackageUidAsUser(pkg, /*flags*/ 0, userId);
                    AppOpsManager aom = ctx.getSystemService(AppOpsManager.class);
                    aom.setUidMode(op, uid, AppOpsManager.MODE_ALLOWED); // 需 MANAGE_APP_OPS_MODES
                }
            } catch (SecurityException | IllegalArgumentException e) {
                // 权限不受支持、没有对应映射、或策略拒绝（见“限制与注意”）
                e.printStackTrace();
            }
        }
    }

    // 撤销
    public static void revokeDangerousPermissionsForUser(Context ctx, String pkg, int userId, String... perms) {
        PackageManager pm = ctx.getPackageManager();
        UserHandle target = UserHandle.of(userId);

        for (String p : perms) {
            try {
                pm.revokeRuntimePermission(pkg, p, target);
                String op = AppOpsManager.permissionToOp(p);
                if (op != null) {
                    int uid = pm.getPackageUidAsUser(pkg, /*flags*/ 0, userId);
                    AppOpsManager aom = ctx.getSystemService(AppOpsManager.class);
                    aom.setUidMode(op, uid, AppOpsManager.MODE_DEFAULT); // 或 MODE_IGNORED，按需
                }
            } catch (SecurityException | IllegalArgumentException e) {
                e.printStackTrace();
            }
        }
    }
}
```

要点与注意
- API 输入维度：grantRuntimePermission/revokeRuntimePermission 以“包名 + 目标用户（UserHandle）”为参数，而不是 UID。你可以用 getPackageUidAsUser(pkg, 0, userId) 取得对应 UID，用于 AppOps。
- 跨用户权限：从 U0 操作 U10/U11 时，需要 INTERACT_ACROSS_USERS(_FULL)。仅创建目标用户上下文（createContextAsUser）通常不足以绕过策略检查。
- 受策略/角色限制的敏感权限：
  - 电话/短信/通话记录等“硬限制”危险权限，可能需要应用成为相应 Role（如默认拨号器、默认短信）或被 OEM/PermissionPolicy 允许，直接 grant 可能失败。
  - ACCESS_BACKGROUND_LOCATION 通常要求先授予前台定位（COARSE/ FINE），否则策略会拒绝。
  - POST_NOTIFICATIONS、BODY_SENSORS_BACKGROUND 等也可能受额外策略或 AppOps 控制。
- AppOps 与权限的双重门禁：
  - 现代 Android 中，许多危险权限既看“权限是否已授予”，也看对应 AppOps 是否允许。多数情况下 PackageManager 会联动设置，但不同版本/定制 ROM 行为可能不同；必要时手动设置 AppOps（需 MANAGE_APP_OPS_MODES）。
- 目标用户未安装该包：grant/revoke 会抛异常。可先用 getPackageUidAsUser 检查；抛 NameNotFoundException 说明该用户未安装。
- 合规与体验：跨用户静默改权限会影响安全与用户预期，确保设备场景（专用设备/企业）与政策允许。

调试对照（ADB）
```
adb shell pm grant --user 10 com.example.android android.permission.CAMERA
adb shell pm revoke --user 10 com.example.android android.permission.CAMERA
```

如果你希望基于 UID 直接控制操作层面（而非权限层面），也可以用 AppOps 仅按 uid 设置模式：
```java
AppOpsManager aom = context.getSystemService(AppOpsManager.class);
aom.setUidMode(AppOpsManager.OPSTR_CAMERA, /*uid*/ targetUid, AppOpsManager.MODE_ALLOWED);
```
但请记住：对映射到危险权限的能力，通常需要“权限已授予”与“AppOps 允许”同时满足，单改其一可能无效。