在 Android 中检查“自己是否拥有某项权限”的方法取决于权限类型与系统版本。以下是最常用、可靠的做法。

一、普通运行时权限（dangerous）
- 典型示例：相机、定位、存储、麦克风、通讯录等
- 检查是否已授予：
  Kotlin:
  val granted = ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED
  if (granted) {
      // 已拥有
  } else {
      // 需请求权限
  }

  Java:
  boolean granted = ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED;

- 若未授予，向用户请求（在 Activity/Fragment 中）：
  ActivityCompat.requestPermissions(activity, new String[]{Manifest.permission.CAMERA}, REQ_CODE);

- 特殊注意
  - Android 13+（API 33）把存储媒体细分为 READ_MEDIA_IMAGES/VIDEO/AUDIO。
  - Android 10+ 存储策略变化，优先使用分区存储或系统选择器。

二、特殊权限（需要 Settings 页面授权）
这些不属于普通运行时权限，checkSelfPermission 不适用，需要用对应 API 检查。

- 悬浮窗：SYSTEM_ALERT_WINDOW
  val canDraw = Settings.canDrawOverlays(context)
  若 false，引导至 Settings.ACTION_MANAGE_OVERLAY_PERMISSION。

- 写系统设置：WRITE_SETTINGS
  val canWrite = Settings.System.canWrite(context)
  若 false，引导至 Settings.ACTION_MANAGE_WRITE_SETTINGS。

- 通知权限（Android 13+）：POST_NOTIFICATIONS
  val granted = if (Build.VERSION.SDK_INT >= 33) {
      ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED
  } else true

- 精确闹钟（Android 12+）：SCHEDULE_EXACT_ALARM
  val canScheduleExact = if (Build.VERSION.SDK_INT >= 31) {
      context.getSystemService(AlarmManager::class.java).canScheduleExactAlarms()
  } else true

- 通知监听：BIND_NOTIFICATION_LISTENER_SERVICE
  val enabled = NotificationManagerCompat.getEnabledListenerPackages(context).contains(context.packageName)

- 无障碍：BIND_ACCESSIBILITY_SERVICE
  val enabled = Settings.Secure.getString(context.contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES)
      ?.contains(context.packageName) == true

- 安装未知应用（Android 8+）：REQUEST_INSTALL_PACKAGES
  val allowed = if (Build.VERSION.SDK_INT >= 26) context.packageManager.canRequestPackageInstalls() else true

- 后台精准定位（Android 10+）：ACCESS_BACKGROUND_LOCATION
  需与前台定位权限一起判断，并根据版本区分：
  val hasForeground = ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED
  val hasBackground = if (Build.VERSION.SDK_INT >= 29)
      ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_BACKGROUND_LOCATION) == PackageManager.PERMISSION_GRANTED
  else true

三、受设备策略或资料空间影响的权限
- 在工作资料或受管设备上，某些权限可能被策略阻止。可通过 DevicePolicyManager 判断策略或捕捉 SecurityException。

四、组合判断与实用函数示例（Kotlin）
- 判断一组运行时权限是否全部授予：
fun hasPermissions(context: Context, vararg perms: String): Boolean {
    return perms.all { ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED }
}

- 在 Android 6.0 以下（API < 23），checkSelfPermission 总是返回已授权（安装时授权模型），但为了兼容性仍可调用。

五、别忘了在 Manifest 声明
- 所有需要检查/请求的权限必须先在 AndroidManifest.xml 中声明，否则请求会直接失败或返回未授予。
  <uses-permission android:name="android.permission.CAMERA" />
  <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

如果你提供目标权限和最低/目标 SDK、系统版本，我可以给出精确的判断与请求流程代码。